#+TITLE: Bearguns Emacs
#+AUTHOR: Sean Brage

[[./logo-sm.jpg]]
This file represents the most recent attempt to sanitize,
standardize and improve my Emacs configuration. Emacs is the tool I use the most
during my day, both for work and personal reasons. I use Emacs for
everything from programming and system administration, to journaling
and task management. Over the years, Emacs has become a truly
indispensible part of my daily workflow.

* About this document
This README is written in the Org syntax -- that is, it's an
=org-mode= document. This means that if you were to view the raw text
of this file, you would see a clean, structured markup syntax
providing headings, emphasis, links, etc.

/However/, if you were to then open this file inside of Emacs and
enable the =org-mode= [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Major-Modes.html][major mode]], this file would gain
superpowers. [[https://orgmode.org/][Org mode]] is like Markdown, only exposed to nuclear
radiation and granted godlike abilities. There's hardly enough space
to cover these magical powers here in this document, but there is one
worth mentioning upfront: the power of styling /and processing/ blocks
of source code. That means that the code blocks you'll encounter
further on in this document actually get "tangled" (that is to say,
processed) out of this document into a =.el= file, which Emacs then
uses to configure itself on startup.

It sounds like science fiction, but I assure you, it's true. Read on,
bear cubs, and enjoy the config.

* Startup
As your Emacs configuration grows, particularly as you begin using
more and more packages and scripts to extend Emacs, the amount of time
it takes for Emacs to be ready can also grow. These are settings I've
found that improve the Emacs startup time. This code gets tangled into
a file called =early-init.el=, which is newly-supported as of Emacs
version 27. =early-init.el= is evaluated -- you guessed it! -- early
in the Emacs initialization process, so code put here will be run
/first/. It's the perfect place to do early optimizations.
** Garbage collection
The garbage collector in Emacs is a frequent offender as regards
crimes of slowdown. There are a few popular tweaks we can make to
speed things up by delaying when the GC is going to kick in:
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;; Adjusts the Emacs garbage collector
(setq gc-cons-threshold most-positive-fixnum)
#+END_SRC

** Package initialization
The built-in Emacs package manager can also slowdown our initial
startup, so we can delay it until it's needed.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;; Delays enabling Emacs' package manager
(setq package-enable-at-startup nil)
(advice-add #'package--ensure-init-file :override #'ignore)
#+END_SRC

** UI rendering
There are UI elements that we don't need to have rendered until we're
actually ready to /use/ Emacs, so we can delay rendering them:
#+BEGIN_SRC emacs-lisp :tangle early-init.el
;; Delay rendering certain (unwanted) UI elements
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
;; Delay resizing the Emacs frame
(setq frame-inhibit-implied-resize t)
#+END_SRC

* Emacs defaults
Out-of-the-box, Emacs is a powerful, capable editor with a wide
variety of features and capabilities. That said, there are elements of
this default behavior that I find less than ideal.

** Backup & autosave
Emacs tries to be "helpful" by creating autosave and backup files for
you. However, these can be very annoying to deal with in
version-controlled software projects, as they need to be explicitly
added to something like =.gitignore= to prevent polluting the source
code.

One thing we can do to combat this, is keep backup files stored in a
central location on our system, instead of inline with the files they
represent:
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun bg-backup-file-name (fpath)
  "Return a new file path of FPATH.  If the new path's directories does not exist, create them."
  (let* (
        (backupRootDir "~/.emacs.d/backup/")
        (filePath (replace-regexp-in-string "[A-Za-z]:" "" fpath )) ; remove Windows driver letter in path, for example, “C:”
        (backupFilePath (replace-regexp-in-string "//" "/" (concat backupRootDir filePath "~") ))
        )
    (make-directory (file-name-directory backupFilePath) (file-name-directory backupFilePath))
    backupFilePath
  )
)
(setq make-backup-file-name-function 'bg-backup-file-name)
;; make backup to a designated dir, mirroring the full path
#+END_SRC

Additionally, we can just disable creation of autosave and lockfiles:
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq auto-save-default nil)
(setq create-lockfiles nil)
;; don't pollute the waters with these special files.
#+END_SRC

* Tramp & remote files
Tramp is an incredible Emacs mode that allows you to directly edit and
interact with remote files and filesystems over SSH, without leaving
the comfort of your own local environment. These settings help provide
a performant, consistent experiencewhen using Tramp.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq tramp-default-remote-shell "/bin/sh")
#+END_SRC

* Packages
Emacs includes a built-in package manager for installing (downloading)
and "requiring" (loading into the active context) packages, much like
the VS Code marketplace. Only better. Using these packages requires
making use of built-in functions to connect to and load packages from
a remote repository.

** Repositories
The ELPA repository that Emacs points to by default is (I'm sure),
just fine. However, everything I want to install and use is available
on the MELPA repository! This block configures Emacs to refer to MELPA
for installing third-party packages:
#+BEGIN_SRC emacs-lisp :tangle init.el
(require 'package)
;; require the built-in "package" package
(add-to-list 'package-archives
	     '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives
	     '("gnu" . "https://elpa.gnu.org/packages/"))
;; Make sure Melpa is our go-to package repository!
(package-initialize)
#+END_SRC

** Package install helper(s)
I thought I would be smart and hand-roll my own solution for
installing and requiring packages. I now see the error of my ways.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun bg-require-package (package)
  "Install PACKAGE if not found on startup."
  (if (package-installed-p package)
      t
    (progn
      (unless (assoc package package-archive-contents)
	(package-refresh-contents))
        (package-install package)
        (require package))))
;; helper function to install packages (can be reused!).
(setq use-package-always-ensure t)
(bg-require-package 'use-package)
#+END_SRC

* Editor Settings
** Editor Defaults
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-display-line-numbers-mode)
;; always display line numbers with the new fast way

(require 'misc)
;; load some improvements to how cursor movements etc. work.

(electric-pair-mode 1)
;; Auto-close delimiters like (,",{,etc.

(add-hook 'prog-mode-hook 'electric-indent-mode)
(setq-default tab-always-indent 'complete)
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
;; Fixes for indentation behaviors when coding

(setq-default cursor-type 'box)
;; Improve cursor visibility in buffers.
#+END_SRC

** Evil
Emacs as a text editor has a lot to offer. However, I’ve found that
the keybindings are difficult for me and at least personally, lead to
a noticable amount of pinky and arm pain by the end of a long
programming session. In this regard, I think that the Evil package
provides a truly great editing experience.

If you want to use evil, uncomment all this stuff.
#+BEGIN_SRC emacs-lisp :tangle init.el
;;(setq-default evil-want-C-u-delete t)
;;(setq-default evil-want-C-u-scroll t)
;;(setq-default evil-want-C-d-scroll t)
;;(setq-default evil-respect-visual-line-mode t)
;;(setq-default evil-show-paren-range 1)
;;(setq-default evil-escape-key-sequence "jk")
;;(bg-require-package 'evil)
;;(bg-require-package 'evil-leader)
;;(bg-require-package 'evil-escape)
;;
;;(evil-mode 1)
;;
;;;; Undotree is poop and crashes Emacs every time I try to use it
;;(global-undo-tree-mode -1)
;;(global-evil-leader-mode)
;;(evil-escape-mode 1)
;;
;;(evil-leader/set-leader "<SPC>")
;;(evil-leader/set-key
;;  "wo" 'other-window
;;  "w0" 'delete-window
;;  "w1" 'delete-other-windows
;;  "w2" 'bg-split-v
;;  "w3" 'bg-split-h)
;;  
;;  
;;(evil-leader/set-key "fs" 'save-buffer)
#+END_SRC

** Snippets
YASnippet provides a way to quickly and easily expand abbreviations
into full snippets of text, code, etc. All with easy movement between
predefined locations within the expanded snippet!
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yasnippet
  :config (yas-global-mode))
#+END_SRC
* The Emacs UI
** Defaults & Performance
There are some tricks I've copied and pasted that, while beyond my
understanding, seem to make Emacs snappier but YMMV.
*** UI defaults
#+BEGIN_SRC emacs-lisp :tangle init.el
(show-paren-mode 1)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
;; Hide the default UI chrome.

(setq ring-bell-function 'ignore)
;; LEAVE ME ALONE EMACS I GET IT I MADE A MISTAKE.
#+END_SRC

*** Startup screen
Override default startup behavior:
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq inhibit-startup-message t
    inhibit-startup-echo-area-message user-login-name
    inhibit-default-init t
    initial-major-mode 'fundamental-mode
    initial-scratch-message nil)
#+END_SRC

Add a nice dashboard with recents, bookmarks, etc:
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package dashboard
  :ensure t
  :init
  (setq dashboard-center-content t)
  (setq dashboard-items '((recents . 5)
                          (projects . 5)
                          (bookmarks . 5)))
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq-default dashboard-startup-banner "~/.emacs.d/logo-sm.png")
  :config 
  (dashboard-setup-startup-hook))
#+END_SRC

*** Performance enhancements
#+BEGIN_SRC emacs-lisp
(setq idle-update-delay 1.0)

(setq-default bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right)

(setq ffap-machine-p-known 'reject)

(setq gcmh-idle-delay 5
      gcmh-high-cons-threshold (* 16 1024 1024))
#+END_SRC

*** Scrolling & point
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq-default cursor-in-non-selected-windows nil)
;; hide point in non-selected windows to make it easier to find active window
(setq highlight-nonselected-windows nil)
;; don't highlight nonselected windows for visual clarity
(setq fast-but-imprecise-scrolling t)
;; scroll faster!
(setq scroll-conservatively 25)
;; when moving cursor to bottom of screen, start scrolling at 25 lines away from bottom
#+END_SRC

** Theming
   Emacs can be themed in a number of ways, the most basic being
   applying a color scheme. While themes can be installed from
   ELPA/MELPA, they can also be loaded from a custom themes directly
   (for hand-rolled themes etc.). My current favorite theme is subject
   to change and possible enhancements.

#+BEGIN_SRC emacs-lisp :tangle init.el
(add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
(use-package night-owl-theme
  :config (load-theme 'night-owl t))
;;(load-theme 'misterioso)
#+END_SRC

** Frills and thrills
Fancy modelines! Nyan cats! Icons!
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package nyan-mode
  :init
  (setq nyan-animate-nyancat t)
  :config
  (nyan-mode 1))

(use-package all-the-icons)

(use-package spaceline
  :config
  (spaceline-emacs-theme))

(use-package spaceline-all-the-icons 
  :after spaceline
  :config (spaceline-all-the-icons-theme))

(use-package neotree
  :init
  (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
  (global-set-key (kbd "C-c t") 'neotree-toggle))

(use-package rainbow-delimiters
  :mode "\\.pco\\'"
  :hook ((prog-mode . rainbow-delimiters-mode)
         (conf-mode . rainbow-delimiters-mode)))

(use-package rainbow-mode
  :hook ((prog-mode . rainbow-mode)
         (conf-mode . rainbow-mode)
         (css-mode  . rainbow-mode)
         (web-mode  . rainbow-mode)))
#+END_SRC

* Window Management
Emacs makes it easy to split the frame into multiple windows. I have a
few modifications I like to make to enhance the default behavior.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun bg-split-h ()
  "Split window right"
  (interactive)
  (split-window-right)
  (other-window 1))
(defun bg-split-v ()
  "Split window below"
  (interactive)
  (split-window-below)
  (other-window 1))
;; Functions to split window and move focus to new windows

(global-set-key (kbd "C-x 2") 'bg-split-v)
(global-set-key (kbd "C-x 3") 'bg-split-h)
;; Override default split bindings with split-and-follow functions
#+END_SRC

* Font Settings
I work half my time on a laptop screen, and the other half connected
to a big 4k display. It’s helpful to set the font size accordingly
when I start Emacs.
#+BEGIN_SRC emacs-lisp :tangle init.el
(when window-system
  (if (> (x-display-pixel-width) 2560)
      (set-face-attribute 'default nil
			  :family "UbuntuMono Nerd Font Mono"
			  :height 160
			  :weight 'normal
			  :width 'normal)
    (set-face-attribute 'default nil
			:family "UbuntuMono Nerd Font Mono"
			:height 130
			:weight 'normal
			:width 'normal)))
;; Set font face and appropriate size based on display size.

(unless (member "all-the-icons" (font-family-list))
  (all-the-icons-install-fonts t))
;; Install...well, all of the icons.
#+END_SRC

* $PATH
Unfortunately, I can't always guaruntee that the system =$PATH=
variable is respected by Emacs consistently across systems. This
package, [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] makes this a non-issue.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package exec-path-from-shell
  :config (exec-path-from-shell-initialize))

(use-package add-node-modules-path
  :hook ((js-mode . add-node-modules-path)
         (typescript-mode . add-node-modules-path)
         (prettier-js-mode . add-node-modules-path)))
#+END_SRC

* Org mode
As discussed above, =org-mode= is like having a rich, easy markup
language for formatting and exporting documents, and /also/ having
radical X-men powers. Like Lucy in the movie /Lucy/, I'm also only
using 10% of Org's potential, but the settings below provide features
I find useful.

*** Defaults
=auto-fill=mode= ensures that lines in org files will break at 80
characters (or the set length). This is helpful for writing prose, and
for the less programmatic nature of my org
documents.
#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'org-mode-hook 'auto-fill-mode)
(add-hook 'org-mode-hook 'visual-line-mode)
#+END_SRC

*** Pomodoro
The pomodoro technique is a useful tool for focus and productivity,
and there's a great package that allows you to start pomodoro timers
for =TODO= items in your =.org= files:
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package org-pomodoro)
#+END_SRC

*** Journaling
Journaling is a habit I'm trying to get back into, and there's a
simple helper package that enables a wide variety of journaling
features in Emacs:
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package org-journal)
(setq org-journal-dir "~/org/journal/")
#+END_SRC

* Ivy, Counsel, and Swiper
These 3 packages provide a wonderful, rapid workflow for searching and
finding things in Emacs. I encourage you to read more about them on
your own time.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ivy
  :init (setq ivy-use-virtual-buffers t)
  :config
  (global-set-key (kbd "C-c C-r") 'ivy-resume)
  (ivy-mode 1))
(use-package counsel
  :config
  (global-set-key (kbd "C-c g") 'counsel-git)
  (global-set-key (kbd "C-c j") 'counsel-git-grep)
  (global-set-key (kbd "C-c k") 'counsel-ag)
  (global-set-key (kbd "\C-s") 'swiper)
  (counsel-mode 1))
#+END_SRC
* Company Mode
Company is the best-in-class solution for code completion in Emacs.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package company
  :hook ((prog-mode . company-mode)
         (conf-mode . company-mode)
         (web-mode  . company-mode)
         (lsp-mode  . company-mode))
  :init
  (setq company-idle-delay 0.1
        company-minimum-prefix-length 2)
  (setq-default company-tooltip-align-annotations t))
  
(use-package company-box
  :hook (company-mode . company-box-mode))
#+END_SRC
* Git
The way I'm able to do my daily work of programming in Git
repositories within Emacs is what has kept me so invested in the
platform.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package magit
  :config
  (setq magit-refresh-status-buffer nil)
  (setq vc-handled-backends nil)
  (global-set-key (kbd "C-x g") 'magit))

(use-package projectile
  :config
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (projectile-mode 1))

(use-package counsel-projectile
  :config (counsel-projectile-mode 1))
#+END_SRC

* Linting and formatting source code
** Flycheck
Flycheck is an awesome tool that hooks into syntax checkers like
ESLint etc.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package flycheck
  :hook ((prog-mode . flycheck-mode)
         (conf-mode . flycheck-mode)
         (web-mode  . flycheck-mode)
         (css-mode  . flycheck-mode))
  :config
  (setq-default flycheck-emacs-lisp-load-path 'inherit)
  (setq-default flycheck-highlighting-mode 'lines)
  (setq-default flycheck-indication-mode 'right-fringe))
#+END_SRC
** Editorconfig
Editorconfig is a program that allows definition of coding standards
(spacing, end-of-file-newlines, charsets etc.) in a text file, and
automagically configuring your editor to respect those settings.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package editorconfig
  :config (editorconfig-mode 1))
#+END_SRC
* Web Development
** Web-mode
Web-mode is a great package for adding syntax, checking, etc. to
markup files like HTML, Handlebars, etc. It also works great for VueJS
with a little massaging.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun bg-vue-mode ()   
    (when (and (stringp buffer-file-name)   
           (string-match "\\.vue\\'" buffer-file-name))
           (lsp)
           (prettier-js-mode 1)
           (setq web-mode-script-padding 0)
           (setq web-mode-style-padding 0)
           (setq web-mode-markup-indent-offset 2)
           (setq web-mode-css-indent-offset 2)
           (setq web-mode-code-indent-offset 2)))

(use-package web-mode
  :mode (("\\.html\\'" . web-mode)
         ("\\.hbs\\'" . web-mode)
         ("\\.vue\\'" . web-mode)
         ("\\.erb\\'" . web-mode))
  :hook (web-mode . bg-vue-mode))
#+END_SRC
** Emmet
Emmet provides a simple DSL for adding HTML tags to a document with a
simple shorthand. It's a must-have!
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package emmet-mode
  :hook web-mode)
#+END_SRC

** SASS
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package scss-mode
  :mode "\\.scss\\'")
#+END_SRC

* LSP
The language server protocol is a tool developed by MSFT (gasp!) to
provide an intellisense-like experience to any editor. With Emacs
27.1 adding native JSON parsing, LSP finally works in a fairly quick
and responsive way!

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package lsp
  :hook ((ruby-mode . lsp)
         (js-mode . lsp)
         (typescript-mode . lsp)))
#+END_SRC

* JavaScript
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq js-offset-indent 2)

(use-package prettier-js
  :hook (js-mode . prettier-js-mode))
#+END_SRC

* Writing & markup languages
** TODO add documentation for this section
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package yaml-mode)
(use-package markdown-mode)

(add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))

(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(autoload 'gfm-mode "markdown-mode"
   "Major mode for editing GitHub Flavored Markdown files" t)
(add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+END_SRC
